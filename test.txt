#include "lang/lexer/test_lexer.h"

#include "lang/lexer/lexer_helper.h"
#include "util/string.h"

const char *token_type_to_str(TokenType token_type) {
  switch(token_type) {
    case SYMBOL_TILDE: return "~";
    case SYMBOL_EXCLAIM2: return "!!";
    case SYMBOL_EXCLAIM: return "!";
    case SYMBOL_AT: return "@";
    case SYMBOL_POUND: return "#";
    case SYMBOL_DOLLAR: return "$";
    case SYMBOL_PERCENT: return "%";
    case SYMBOL_CARET: return "^";
    case SYMBOL_AMPER2: return "&&";
    case SYMBOL_AMPER: return "&";
    case SYMOBL_STAR2: return "**";
    case SYMOBL_STAR: return "*";
    case SYMBOL_LPAREN: return "(";
    case SYMBOL_RPAREN: return ")";
    case SYMBOL_ARROW: return "->";
    case SYMBOL_DASH: return "-";
    case SYMBOL_PLUS: return "+";
    case SYMBOL_EQUAL: return "=";
    case SYMBOL_EQUAL2: return "==";
    case SYMBOL_LBRACE: return "{";
    case SYMBOL_RBRACE: return "}";
    case SYMBOL_LBRACKET: return "[";
    case SYMBOL_RBRACKET: return "]";
    case SYMBOL_PIPE: return "|";
    case SYMBOL_BACKSLASH: return "\\";
    case SYMBOL_COLON: return ":";
    case SYMBOL_SEMICOLON: return ";";
    case SYMBOL_NOTEQUAL: return "!=";
    case SYMBOL_LESSTHANEQUAL: return "<=";
    case SYMBOL_LESSTHAN: return "<";
    case SYMBOL_COMMA: return ",";
    case SYMBOL_GREATERTHANEQUAL: return ">=";
    case SYMBOL_GREATERTHAN: return ">";
    case SYMBOL_PERIOD: return ".";
    case SYMBOL_QUESTION2: return "??";
    case SYMBOL_QUESTION: return "?";
    case SYMBOL_FORWARDSLASH: return "/";
    case KEYWORD_AND: return "and";
    case KEYWORD_OR: return "or";
    case KEYWORD_NOT: return "not";
    case KEYWORD_RETURN: return "return";
    case KEYWORD_FOR: return "for";
    case KEYWORD_WHILE: return "while";
    case KEYWORD_IF: return "if";
    case KEYWORD_ELSE: return "else";
    case KEYWORD_FUNCTION: return "function";
    case KEYWORD_METHOD: return "method";
    case KEYWORD_CLASS: return "class";
    case KEYWORD_CONST: return "const";
    case KEYWORD_READONLY: return "readonly";
    case KEYWORD_FIELD: return "field";
    case ENDLINE: return "\n";
    default: return "UNKNOWN";
  }
}

TokenType symbol_type(const char word[]) {
  switch (word[0]) {
  case '!':
    switch (word[1]) {
    case '!':
      return SYMBOL_EXCLAIM2;
    case '=':
      return SYMBOL_NOTEQUAL;
    default: break;
    }
    return SYMBOL_EXCLAIM;
  case '#':
    return SYMBOL_POUND;
  case '$':
    return SYMBOL_DOLLAR;
  case '%':
    return SYMBOL_PERCENT;
  case '&':
    switch (word[1]) {
    case '&':
      return SYMBOL_AMPER2;
    default: break;
    }
    return SYMBOL_AMPER;
  case '(':
    return SYMBOL_LPAREN;
  case ')':
    return SYMBOL_RPAREN;
  case '*':
    switch (word[1]) {
    case '*':
      return SYMOBL_STAR2;
    default: break;
    }
    return SYMOBL_STAR;
  case '+':
    return SYMBOL_PLUS;
  case ',':
    return SYMBOL_COMMA;
  case '-':
    switch (word[1]) {
    case '>':
      return SYMBOL_ARROW;
    default: break;
    }
    return SYMBOL_DASH;
  case '.':
    return SYMBOL_PERIOD;
  case '/':
    return SYMBOL_FORWARDSLASH;
  case ':':
    return SYMBOL_COLON;
  case ';':
    return SYMBOL_SEMICOLON;
  case '<':
    switch (word[1]) {
    case '=':
      return SYMBOL_LESSTHANEQUAL;
    default: break;
    }
    return SYMBOL_LESSTHAN;
  case '=':
    switch (word[1]) {
    case '=':
      return SYMBOL_EQUAL2;
    default: break;
    }
    return SYMBOL_EQUAL;
  case '>':
    switch (word[1]) {
    case '=':
      return SYMBOL_GREATERTHANEQUAL;
    default: break;
    }
    return SYMBOL_GREATERTHAN;
  case '?':
    switch (word[1]) {
    case '?':
      return SYMBOL_QUESTION2;
    default: break;
    }
    return SYMBOL_QUESTION;
  case '@':
    return SYMBOL_AT;
  case '[':
    return SYMBOL_LBRACKET;
  case '\\':
    switch (word[1]) {
    case '\\':
      return SYMBOL_BACKSLASH;
    default: break;
    }
  case ']':
    return SYMBOL_RBRACKET;
  case '^':
    return SYMBOL_CARET;
  case '{':
    return SYMBOL_LBRACE;
  case '|':
    return SYMBOL_PIPE;
  case '}':
    return SYMBOL_RBRACE;
  case '~':
    return SYMBOL_TILDE;
  default: break;
  }
  return TOKENTYPE_UNKNOWN;
}

TokenType _keyword_type(const char word[], int word_len) {
  if (word_len <= 0) { return ENDLINE; }
  switch (word[0]) {
  case 'a':
    switch (word[1]) {
    case 'n':
      switch (word[2]) {
      case 'd':
        if (word_len == 3) { return KEYWORD_AND; }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'c':
    switch (word[1]) {
    case 'l':
      switch (word[2]) {
      case 'a':
        switch (word[3]) {
        case 's':
          switch (word[4]) {
          case 's':
            if (word_len == 5) { return KEYWORD_CLASS; }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    case 'o':
      switch (word[2]) {
      case 'n':
        switch (word[3]) {
        case 's':
          switch (word[4]) {
          case 't':
            if (word_len == 5) { return KEYWORD_CONST; }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'e':
    switch (word[1]) {
    case 'l':
      switch (word[2]) {
      case 's':
        switch (word[3]) {
        case 'e':
          if (word_len == 4) { return KEYWORD_ELSE; }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'f':
    switch (word[1]) {
    case 'i':
      switch (word[2]) {
      case 'e':
        switch (word[3]) {
        case 'l':
          switch (word[4]) {
          case 'd':
            if (word_len == 5) { return KEYWORD_FIELD; }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    case 'o':
      switch (word[2]) {
      case 'r':
        if (word_len == 3) { return KEYWORD_FOR; }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    case 'u':
      switch (word[2]) {
      case 'n':
        switch (word[3]) {
        case 'c':
          switch (word[4]) {
          case 't':
            switch (word[5]) {
            case 'i':
              switch (word[6]) {
              case 'o':
                switch (word[7]) {
                case 'n':
                  if (word_len == 8) { return KEYWORD_FUNCTION; }
                  return TOKENTYPE_UNKNOWN;
                default: return TOKENTYPE_UNKNOWN;
                }
                return TOKENTYPE_UNKNOWN;
              default: return TOKENTYPE_UNKNOWN;
              }
              return TOKENTYPE_UNKNOWN;
            default: return TOKENTYPE_UNKNOWN;
            }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'i':
    switch (word[1]) {
    case 'f':
      if (word_len == 2) { return KEYWORD_IF; }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'm':
    switch (word[1]) {
    case 'e':
      switch (word[2]) {
      case 't':
        switch (word[3]) {
        case 'h':
          switch (word[4]) {
          case 'o':
            switch (word[5]) {
            case 'd':
              if (word_len == 6) { return KEYWORD_METHOD; }
              return TOKENTYPE_UNKNOWN;
            default: return TOKENTYPE_UNKNOWN;
            }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'n':
    switch (word[1]) {
    case 'o':
      switch (word[2]) {
      case 't':
        if (word_len == 3) { return KEYWORD_NOT; }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'o':
    switch (word[1]) {
    case 'r':
      if (word_len == 2) { return KEYWORD_OR; }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'r':
    switch (word[1]) {
    case 'e':
      switch (word[2]) {
      case 'a':
        switch (word[3]) {
        case 'd':
          switch (word[4]) {
          case 'o':
            switch (word[5]) {
            case 'n':
              switch (word[6]) {
              case 'l':
                switch (word[7]) {
                case 'y':
                  if (word_len == 8) { return KEYWORD_READONLY; }
                  return TOKENTYPE_UNKNOWN;
                default: return TOKENTYPE_UNKNOWN;
                }
                return TOKENTYPE_UNKNOWN;
              default: return TOKENTYPE_UNKNOWN;
              }
              return TOKENTYPE_UNKNOWN;
            default: return TOKENTYPE_UNKNOWN;
            }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      case 't':
        switch (word[3]) {
        case 'u':
          switch (word[4]) {
          case 'r':
            switch (word[5]) {
            case 'n':
              if (word_len == 6) { return KEYWORD_RETURN; }
              return TOKENTYPE_UNKNOWN;
            default: return TOKENTYPE_UNKNOWN;
            }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  case 'w':
    switch (word[1]) {
    case 'h':
      switch (word[2]) {
      case 'i':
        switch (word[3]) {
        case 'l':
          switch (word[4]) {
          case 'e':
            if (word_len == 5) { return KEYWORD_WHILE; }
            return TOKENTYPE_UNKNOWN;
          default: return TOKENTYPE_UNKNOWN;
          }
          return TOKENTYPE_UNKNOWN;
        default: return TOKENTYPE_UNKNOWN;
        }
        return TOKENTYPE_UNKNOWN;
      default: return TOKENTYPE_UNKNOWN;
      }
      return TOKENTYPE_UNKNOWN;
    default: return TOKENTYPE_UNKNOWN;
    }
    return TOKENTYPE_UNKNOWN;
  default: return TOKENTYPE_UNKNOWN;
  }
  return TOKENTYPE_UNKNOWN;
}

TokenType resolve_type(const char word[], int word_len) {
  TokenType type = symbol_type(word);
  if (TOKENTYPE_UNKNOWN == type) { type = _keyword_type(word, word_len); }
  if (TOKENTYPE_UNKNOWN != type) { return type; }
  if (is_number(word[0])) {
    if (ends_with(word, "f") || contains_char(word, '.')) {
      return TOKEN_FLOATING;
    } else { return TOKEN_INTEGER; }
  }
  return type;
}

bool is_start_of_symbol(const char word[]) {
  switch (word[0]) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '(':
    case ')':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case '/':
    case ':':
    case ';':
    case '<':
    case '=':
    case '>':
    case '?':
    case '@':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '{':
    case '|':
    case '}':
    case '~':
      return true;
    default: return false;
  }
}

const char *is_start_of_comment(const char word[]) {
  if (0 == strcmp("/*", word)) {
    return "*/";
  }
  if (0 == strcmp("//", word)) {
    return "\n";
  }
  return NULL;
}

