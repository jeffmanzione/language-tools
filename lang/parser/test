
SyntaxTree *rule_or(Parser *parser);

SyntaxTree *rule_identifier(Parser *parser) {
  Token *token = parser_next(parser);
  if (NULL == token || TOKEN_WORD != token->type) {
    return &NO_MATCH;
  }
  return match(parser);
}

inline SyntaxTree *_rule_or1__helper1(Parser *parser) {
  Token *token = parser_next(parser);
  if (NULL == token || KEYWORD_OR != token->type) {
    return &NO_MATCH;
  }
  return match(parser);
}

inline SyntaxTree *_rule_or1__helper0(Parser *parser) {
  // and(...)
  SyntaxTree *st = parser_create_st(parser);
  {
    // START token:KEYWORD_OR
    SyntaxTree *st_child = _rule_or1__helper1(parser);
    // END token:KEYWORD_OR
    if (!st->matched) {
      parser_delete_st(parser, st);
      return &NO_MATCH;
    }
    syntax_tree_add_child(st, st_child);
  }
  {
    // START rule:or
    SyntaxTree *st_child = rule_or(parser);
    // END rule:or
    if (!st->matched) {
      parser_delete_st(parser, st);
      return &NO_MATCH;
    }
    syntax_tree_add_child(st, st_child);
  }
  return st;
}

SyntaxTree *rule_or1(Parser *parser) {
  // or(...)
  {
    // START and(...)
    SyntaxTree *st = _rule_or1__helper0(parser);
    // END and(...)
    if (st->matched) {
      return st;
    }
  }
  {
    // START Epsilon
    return &MATCH_EPSILON;
    // END Epsilon
  }
}

SyntaxTree *rule_or(Parser *parser) {
  // and(...)
  SyntaxTree *st = parser_create_st(parser);
  {
    // START rule:identifier
    SyntaxTree *st_child = rule_identifier(parser);
    // END rule:identifier
    if (!st->matched) {
      parser_delete_st(parser, st);
      return &NO_MATCH;
    }
    syntax_tree_add_child(st, st_child);
  }
  {
    // START rule:or
    SyntaxTree *st_child = rule_or(parser);
    // END rule:or
    if (!st->matched) {
      parser_delete_st(parser, st);
      return &NO_MATCH;
    }
    syntax_tree_add_child(st, st_child);
  }
}